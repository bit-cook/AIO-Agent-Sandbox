# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import httpx
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper

if typing.TYPE_CHECKING:
    from .auth.client import AsyncAuthClient, AuthClient
    from .browser.client import AsyncBrowserClient, BrowserClient
    from .browser_captcha.client import AsyncBrowserCaptchaClient, BrowserCaptchaClient
    from .browser_cookies.client import AsyncBrowserCookiesClient, BrowserCookiesClient
    from .browser_network.client import AsyncBrowserNetworkClient, BrowserNetworkClient
    from .browser_page.client import AsyncBrowserPageClient, BrowserPageClient
    from .browser_state.client import AsyncBrowserStateClient, BrowserStateClient
    from .browser_tabs.client import AsyncBrowserTabsClient, BrowserTabsClient
    from .code.client import AsyncCodeClient, CodeClient
    from .file.client import AsyncFileClient, FileClient
    from .jupyter.client import AsyncJupyterClient, JupyterClient
    from .mcp.client import AsyncMcpClient, McpClient
    from .nodejs.client import AsyncNodejsClient, NodejsClient
    from .sandbox.client import AsyncSandboxClient, SandboxClient
    from .shell.client import AsyncShellClient, ShellClient
    from .skills.client import AsyncSkillsClient, SkillsClient
    from .util.client import AsyncUtilClient, UtilClient


class Sandbox:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : str
        The base url to use for requests from the client.

    headers : typing.Optional[typing.Dict[str, str]]
        Additional headers to send with every request.

    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from agent_sandbox import Sandbox

    client = Sandbox(
        base_url="https://yourhost.com/path/to/api",
    )
    """

    def __init__(
        self,
        *,
        base_url: str,
        headers: typing.Optional[typing.Dict[str, str]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=base_url,
            headers=headers,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self._sandbox: typing.Optional[SandboxClient] = None
        self._shell: typing.Optional[ShellClient] = None
        self._file: typing.Optional[FileClient] = None
        self._jupyter: typing.Optional[JupyterClient] = None
        self._nodejs: typing.Optional[NodejsClient] = None
        self._mcp: typing.Optional[McpClient] = None
        self._browser: typing.Optional[BrowserClient] = None
        self._browser_page: typing.Optional[BrowserPageClient] = None
        self._browser_tabs: typing.Optional[BrowserTabsClient] = None
        self._browser_cookies: typing.Optional[BrowserCookiesClient] = None
        self._browser_state: typing.Optional[BrowserStateClient] = None
        self._browser_network: typing.Optional[BrowserNetworkClient] = None
        self._browser_captcha: typing.Optional[BrowserCaptchaClient] = None
        self._code: typing.Optional[CodeClient] = None
        self._util: typing.Optional[UtilClient] = None
        self._skills: typing.Optional[SkillsClient] = None
        self._auth: typing.Optional[AuthClient] = None

    @property
    def sandbox(self):
        if self._sandbox is None:
            from .sandbox.client import SandboxClient  # noqa: E402

            self._sandbox = SandboxClient(client_wrapper=self._client_wrapper)
        return self._sandbox

    @property
    def shell(self):
        if self._shell is None:
            from .shell.client import ShellClient  # noqa: E402

            self._shell = ShellClient(client_wrapper=self._client_wrapper)
        return self._shell

    @property
    def file(self):
        if self._file is None:
            from .file.client import FileClient  # noqa: E402

            self._file = FileClient(client_wrapper=self._client_wrapper)
        return self._file

    @property
    def jupyter(self):
        if self._jupyter is None:
            from .jupyter.client import JupyterClient  # noqa: E402

            self._jupyter = JupyterClient(client_wrapper=self._client_wrapper)
        return self._jupyter

    @property
    def nodejs(self):
        if self._nodejs is None:
            from .nodejs.client import NodejsClient  # noqa: E402

            self._nodejs = NodejsClient(client_wrapper=self._client_wrapper)
        return self._nodejs

    @property
    def mcp(self):
        if self._mcp is None:
            from .mcp.client import McpClient  # noqa: E402

            self._mcp = McpClient(client_wrapper=self._client_wrapper)
        return self._mcp

    @property
    def browser(self):
        if self._browser is None:
            from .browser.client import BrowserClient  # noqa: E402

            self._browser = BrowserClient(client_wrapper=self._client_wrapper)
        return self._browser

    @property
    def browser_page(self):
        if self._browser_page is None:
            from .browser_page.client import BrowserPageClient  # noqa: E402

            self._browser_page = BrowserPageClient(client_wrapper=self._client_wrapper)
        return self._browser_page

    @property
    def browser_tabs(self):
        if self._browser_tabs is None:
            from .browser_tabs.client import BrowserTabsClient  # noqa: E402

            self._browser_tabs = BrowserTabsClient(client_wrapper=self._client_wrapper)
        return self._browser_tabs

    @property
    def browser_cookies(self):
        if self._browser_cookies is None:
            from .browser_cookies.client import BrowserCookiesClient  # noqa: E402

            self._browser_cookies = BrowserCookiesClient(client_wrapper=self._client_wrapper)
        return self._browser_cookies

    @property
    def browser_state(self):
        if self._browser_state is None:
            from .browser_state.client import BrowserStateClient  # noqa: E402

            self._browser_state = BrowserStateClient(client_wrapper=self._client_wrapper)
        return self._browser_state

    @property
    def browser_network(self):
        if self._browser_network is None:
            from .browser_network.client import BrowserNetworkClient  # noqa: E402

            self._browser_network = BrowserNetworkClient(client_wrapper=self._client_wrapper)
        return self._browser_network

    @property
    def browser_captcha(self):
        if self._browser_captcha is None:
            from .browser_captcha.client import BrowserCaptchaClient  # noqa: E402

            self._browser_captcha = BrowserCaptchaClient(client_wrapper=self._client_wrapper)
        return self._browser_captcha

    @property
    def code(self):
        if self._code is None:
            from .code.client import CodeClient  # noqa: E402

            self._code = CodeClient(client_wrapper=self._client_wrapper)
        return self._code

    @property
    def util(self):
        if self._util is None:
            from .util.client import UtilClient  # noqa: E402

            self._util = UtilClient(client_wrapper=self._client_wrapper)
        return self._util

    @property
    def skills(self):
        if self._skills is None:
            from .skills.client import SkillsClient  # noqa: E402

            self._skills = SkillsClient(client_wrapper=self._client_wrapper)
        return self._skills

    @property
    def auth(self):
        if self._auth is None:
            from .auth.client import AuthClient  # noqa: E402

            self._auth = AuthClient(client_wrapper=self._client_wrapper)
        return self._auth


class AsyncSandbox:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : str
        The base url to use for requests from the client.

    headers : typing.Optional[typing.Dict[str, str]]
        Additional headers to send with every request.

    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from agent_sandbox import AsyncSandbox

    client = AsyncSandbox(
        base_url="https://yourhost.com/path/to/api",
    )
    """

    def __init__(
        self,
        *,
        base_url: str,
        headers: typing.Optional[typing.Dict[str, str]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else httpx_client.timeout.read
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=base_url,
            headers=headers,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self._sandbox: typing.Optional[AsyncSandboxClient] = None
        self._shell: typing.Optional[AsyncShellClient] = None
        self._file: typing.Optional[AsyncFileClient] = None
        self._jupyter: typing.Optional[AsyncJupyterClient] = None
        self._nodejs: typing.Optional[AsyncNodejsClient] = None
        self._mcp: typing.Optional[AsyncMcpClient] = None
        self._browser: typing.Optional[AsyncBrowserClient] = None
        self._browser_page: typing.Optional[AsyncBrowserPageClient] = None
        self._browser_tabs: typing.Optional[AsyncBrowserTabsClient] = None
        self._browser_cookies: typing.Optional[AsyncBrowserCookiesClient] = None
        self._browser_state: typing.Optional[AsyncBrowserStateClient] = None
        self._browser_network: typing.Optional[AsyncBrowserNetworkClient] = None
        self._browser_captcha: typing.Optional[AsyncBrowserCaptchaClient] = None
        self._code: typing.Optional[AsyncCodeClient] = None
        self._util: typing.Optional[AsyncUtilClient] = None
        self._skills: typing.Optional[AsyncSkillsClient] = None
        self._auth: typing.Optional[AsyncAuthClient] = None

    @property
    def sandbox(self):
        if self._sandbox is None:
            from .sandbox.client import AsyncSandboxClient  # noqa: E402

            self._sandbox = AsyncSandboxClient(client_wrapper=self._client_wrapper)
        return self._sandbox

    @property
    def shell(self):
        if self._shell is None:
            from .shell.client import AsyncShellClient  # noqa: E402

            self._shell = AsyncShellClient(client_wrapper=self._client_wrapper)
        return self._shell

    @property
    def file(self):
        if self._file is None:
            from .file.client import AsyncFileClient  # noqa: E402

            self._file = AsyncFileClient(client_wrapper=self._client_wrapper)
        return self._file

    @property
    def jupyter(self):
        if self._jupyter is None:
            from .jupyter.client import AsyncJupyterClient  # noqa: E402

            self._jupyter = AsyncJupyterClient(client_wrapper=self._client_wrapper)
        return self._jupyter

    @property
    def nodejs(self):
        if self._nodejs is None:
            from .nodejs.client import AsyncNodejsClient  # noqa: E402

            self._nodejs = AsyncNodejsClient(client_wrapper=self._client_wrapper)
        return self._nodejs

    @property
    def mcp(self):
        if self._mcp is None:
            from .mcp.client import AsyncMcpClient  # noqa: E402

            self._mcp = AsyncMcpClient(client_wrapper=self._client_wrapper)
        return self._mcp

    @property
    def browser(self):
        if self._browser is None:
            from .browser.client import AsyncBrowserClient  # noqa: E402

            self._browser = AsyncBrowserClient(client_wrapper=self._client_wrapper)
        return self._browser

    @property
    def browser_page(self):
        if self._browser_page is None:
            from .browser_page.client import AsyncBrowserPageClient  # noqa: E402

            self._browser_page = AsyncBrowserPageClient(client_wrapper=self._client_wrapper)
        return self._browser_page

    @property
    def browser_tabs(self):
        if self._browser_tabs is None:
            from .browser_tabs.client import AsyncBrowserTabsClient  # noqa: E402

            self._browser_tabs = AsyncBrowserTabsClient(client_wrapper=self._client_wrapper)
        return self._browser_tabs

    @property
    def browser_cookies(self):
        if self._browser_cookies is None:
            from .browser_cookies.client import AsyncBrowserCookiesClient  # noqa: E402

            self._browser_cookies = AsyncBrowserCookiesClient(client_wrapper=self._client_wrapper)
        return self._browser_cookies

    @property
    def browser_state(self):
        if self._browser_state is None:
            from .browser_state.client import AsyncBrowserStateClient  # noqa: E402

            self._browser_state = AsyncBrowserStateClient(client_wrapper=self._client_wrapper)
        return self._browser_state

    @property
    def browser_network(self):
        if self._browser_network is None:
            from .browser_network.client import AsyncBrowserNetworkClient  # noqa: E402

            self._browser_network = AsyncBrowserNetworkClient(client_wrapper=self._client_wrapper)
        return self._browser_network

    @property
    def browser_captcha(self):
        if self._browser_captcha is None:
            from .browser_captcha.client import AsyncBrowserCaptchaClient  # noqa: E402

            self._browser_captcha = AsyncBrowserCaptchaClient(client_wrapper=self._client_wrapper)
        return self._browser_captcha

    @property
    def code(self):
        if self._code is None:
            from .code.client import AsyncCodeClient  # noqa: E402

            self._code = AsyncCodeClient(client_wrapper=self._client_wrapper)
        return self._code

    @property
    def util(self):
        if self._util is None:
            from .util.client import AsyncUtilClient  # noqa: E402

            self._util = AsyncUtilClient(client_wrapper=self._client_wrapper)
        return self._util

    @property
    def skills(self):
        if self._skills is None:
            from .skills.client import AsyncSkillsClient  # noqa: E402

            self._skills = AsyncSkillsClient(client_wrapper=self._client_wrapper)
        return self._skills

    @property
    def auth(self):
        if self._auth is None:
            from .auth.client import AsyncAuthClient  # noqa: E402

            self._auth = AsyncAuthClient(client_wrapper=self._client_wrapper)
        return self._auth

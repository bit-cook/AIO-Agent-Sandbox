// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as Sandbox from "../../../index.js";

export declare namespace BrowserPage {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class BrowserPage {
    protected readonly _options: BrowserPage.Options;

    constructor(_options: BrowserPage.Options) {
        this._options = _options;
    }

    /**
     * Navigate the current page to a URL.
     *
     * @param {Sandbox.NavigateRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.navigate({
     *         url: "url"
     *     })
     */
    public navigate(
        request: Sandbox.NavigateRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseDict, Sandbox.browserPage.navigate.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__navigate(request, requestOptions));
    }

    private async __navigate(
        request: Sandbox.NavigateRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseDict, Sandbox.browserPage.navigate.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/navigate",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseDict,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.navigate.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.navigate.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Go back in browser history.
     *
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.back()
     */
    public back(
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.back.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__back(requestOptions));
    }

    private async __back(
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.back.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/back",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.back.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Go forward in browser history.
     *
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.forward()
     */
    public forward(
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.forward.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__forward(requestOptions));
    }

    private async __forward(
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.forward.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/forward",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.forward.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Reload the current page.
     *
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.reload()
     */
    public reload(
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.reload.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__reload(requestOptions));
    }

    private async __reload(
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.reload.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/reload",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.reload.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Click an element by selector, index, or coordinates.
     *
     * @param {Sandbox.ClickRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.click()
     */
    public click(
        request: Sandbox.ClickRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.click.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__click(request, requestOptions));
    }

    private async __click(
        request: Sandbox.ClickRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.click.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/click",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.click.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.click.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Fill an input field.
     *
     * @param {Sandbox.FillRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.fill({
     *         text: "text"
     *     })
     */
    public fill(
        request: Sandbox.FillRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.fill.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__fill(request, requestOptions));
    }

    private async __fill(
        request: Sandbox.FillRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.fill.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/fill",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.fill.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.fill.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Type text with optional delay between keystrokes.
     *
     * @param {Sandbox.TypeTextRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.typeText({
     *         text: "text"
     *     })
     */
    public typeText(
        request: Sandbox.TypeTextRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.typeText.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__typeText(request, requestOptions));
    }

    private async __typeText(
        request: Sandbox.TypeTextRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.typeText.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/type",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.typeText.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.typeText.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Press a single key.
     *
     * @param {Sandbox.KeyRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.pressKey({
     *         key: "key"
     *     })
     */
    public pressKey(
        request: Sandbox.KeyRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.pressKey.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__pressKey(request, requestOptions));
    }

    private async __pressKey(
        request: Sandbox.KeyRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.pressKey.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/press_key",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.pressKey.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.pressKey.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Press a key combination.
     *
     * @param {Sandbox.HotKeyRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.hotKey({
     *         keys: ["keys"]
     *     })
     */
    public hotKey(
        request: Sandbox.HotKeyRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.hotKey.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__hotKey(request, requestOptions));
    }

    private async __hotKey(
        request: Sandbox.HotKeyRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.hotKey.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/hot_key",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.hotKey.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.hotKey.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Hover over an element by selector or coordinates.
     *
     * @param {Sandbox.HoverRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.hover()
     */
    public hover(
        request: Sandbox.HoverRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.hover.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__hover(request, requestOptions));
    }

    private async __hover(
        request: Sandbox.HoverRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.hover.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/hover",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.hover.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.hover.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Select an option in a dropdown.
     *
     * @param {Sandbox.SelectOptionRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.selectOption({
     *         selector: "selector"
     *     })
     */
    public selectOption(
        request: Sandbox.SelectOptionRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.selectOption.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__selectOption(request, requestOptions));
    }

    private async __selectOption(
        request: Sandbox.SelectOptionRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.selectOption.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/select_option",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.selectOption.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.selectOption.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Check a checkbox.
     *
     * @param {Sandbox.CheckRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.check({
     *         selector: "selector"
     *     })
     */
    public check(
        request: Sandbox.CheckRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.check.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__check(request, requestOptions));
    }

    private async __check(
        request: Sandbox.CheckRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.check.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/check",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.check.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.check.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Uncheck a checkbox.
     *
     * @param {Sandbox.CheckRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.uncheck({
     *         selector: "selector"
     *     })
     */
    public uncheck(
        request: Sandbox.CheckRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.uncheck.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__uncheck(request, requestOptions));
    }

    private async __uncheck(
        request: Sandbox.CheckRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.uncheck.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/uncheck",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.uncheck.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.uncheck.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Upload files to a file input element.
     *
     * @param {Sandbox.UploadFileRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.uploadFile({
     *         selector: "selector",
     *         files: ["files"]
     *     })
     */
    public uploadFile(
        request: Sandbox.UploadFileRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.uploadFile.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__uploadFile(request, requestOptions));
    }

    private async __uploadFile(
        request: Sandbox.UploadFileRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.uploadFile.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/upload_file",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.uploadFile.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.uploadFile.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Batch fill multiple form fields.
     *
     * @param {Sandbox.FormFillRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.fillForm({
     *         items: [{
     *                 "key": "value"
     *             }]
     *     })
     */
    public fillForm(
        request: Sandbox.FormFillRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.fillForm.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__fillForm(request, requestOptions));
    }

    private async __fillForm(
        request: Sandbox.FormFillRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.fillForm.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/fill_form",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.fillForm.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.fillForm.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Scroll the page in a direction.
     *
     * @param {Sandbox.ScrollRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.scroll()
     */
    public scroll(
        request: Sandbox.ScrollRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.scroll.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__scroll(request, requestOptions));
    }

    private async __scroll(
        request: Sandbox.ScrollRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.scroll.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/scroll",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.scroll.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.scroll.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Scroll to an absolute position.
     *
     * @param {Sandbox.ScrollToRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.scrollTo()
     */
    public scrollTo(
        request: Sandbox.ScrollToRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.scrollTo.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__scrollTo(request, requestOptions));
    }

    private async __scrollTo(
        request: Sandbox.ScrollToRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.scrollTo.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/scroll_to",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.scrollTo.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.scrollTo.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Scroll an element into view.
     *
     * @param {Sandbox.ScrollToElementRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.scrollToElement({
     *         selector: "selector"
     *     })
     */
    public scrollToElement(
        request: Sandbox.ScrollToElementRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.scrollToElement.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__scrollToElement(request, requestOptions));
    }

    private async __scrollToElement(
        request: Sandbox.ScrollToElementRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.scrollToElement.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/scroll_to_element",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.scrollToElement.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.scrollToElement.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Capture a page screenshot.
     */
    public screenshot(
        request: Sandbox.BrowserPageScreenshotRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<core.BinaryResponse, Sandbox.browserPage.screenshot.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__screenshot(request, requestOptions));
    }

    private async __screenshot(
        request: Sandbox.BrowserPageScreenshotRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<core.BinaryResponse, Sandbox.browserPage.screenshot.Error>>> {
        const { full_page: fullPage, format, quality } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (fullPage != null) {
            _queryParams.full_page = fullPage.toString();
        }

        if (format != null) {
            _queryParams.format = format;
        }

        if (quality != null) {
            _queryParams.quality = quality.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/screenshot",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            responseType: "binary-response",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.screenshot.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.screenshot.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Record page screencast (once/start/pause/resume/stop/status).
     *
     * @param {Sandbox.RecordRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.record()
     */
    public record(
        request: Sandbox.RecordRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseDict, Sandbox.browserPage.record.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__record(request, requestOptions));
    }

    private async __record(
        request: Sandbox.RecordRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseDict, Sandbox.browserPage.record.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/record",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseDict,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.record.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.record.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Get the page HTML content.
     *
     * @param {Sandbox.BrowserPageGetHtmlRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.getHtml({
     *         outer: true
     *     })
     */
    public getHtml(
        request: Sandbox.BrowserPageGetHtmlRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseStr, Sandbox.browserPage.getHtml.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getHtml(request, requestOptions));
    }

    private async __getHtml(
        request: Sandbox.BrowserPageGetHtmlRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseStr, Sandbox.browserPage.getHtml.Error>>> {
        const { outer } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (outer != null) {
            _queryParams.outer = outer.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/html",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseStr,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.getHtml.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.getHtml.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Get all visible text from the page.
     *
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.getText()
     */
    public getText(
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseStr, Sandbox.browserPage.getText.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getText(requestOptions));
    }

    private async __getText(
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseStr, Sandbox.browserPage.getText.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/text",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseStr,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.getText.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Get the page content as Markdown using Readability and Turndown.
     *
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.getMarkdown()
     */
    public getMarkdown(
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseDict, Sandbox.browserPage.getMarkdown.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getMarkdown(requestOptions));
    }

    private async __getMarkdown(
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseDict, Sandbox.browserPage.getMarkdown.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/markdown",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseDict,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.getMarkdown.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Get all interactive elements on the page.
     *
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.getElements()
     */
    public getElements(
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseList, Sandbox.browserPage.getElements.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getElements(requestOptions));
    }

    private async __getElements(
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseList, Sandbox.browserPage.getElements.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/elements",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseList,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.getElements.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Get captured browser console log messages.
     *
     * @param {Sandbox.BrowserPageGetConsoleRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.getConsole({
     *         clear: true
     *     })
     */
    public getConsole(
        request: Sandbox.BrowserPageGetConsoleRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseList, Sandbox.browserPage.getConsole.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getConsole(request, requestOptions));
    }

    private async __getConsole(
        request: Sandbox.BrowserPageGetConsoleRequest = {},
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseList, Sandbox.browserPage.getConsole.Error>>> {
        const { clear } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (clear != null) {
            _queryParams.clear = clear.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/console",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseList,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.getConsole.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.getConsole.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Export console logs to a JSON file.
     *
     * @param {Sandbox.ExportConsoleLogsRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.exportConsole({
     *         save_path: "save_path"
     *     })
     */
    public exportConsole(
        request: Sandbox.ExportConsoleLogsRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.exportConsole.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__exportConsole(request, requestOptions));
    }

    private async __exportConsole(
        request: Sandbox.ExportConsoleLogsRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.exportConsole.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/console/export",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.exportConsole.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.exportConsole.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Execute JavaScript and return the result.
     *
     * @param {Sandbox.EvaluateRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.evaluate({
     *         expression: "expression"
     *     })
     */
    public evaluate(
        request: Sandbox.EvaluateRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.evaluate.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__evaluate(request, requestOptions));
    }

    private async __evaluate(
        request: Sandbox.EvaluateRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.evaluate.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/evaluate",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.evaluate.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.evaluate.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Find text occurrences on the page.
     *
     * @param {Sandbox.FindTextRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.findText({
     *         keyword: "keyword"
     *     })
     */
    public findText(
        request: Sandbox.FindTextRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.ResponseList, Sandbox.browserPage.findText.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__findText(request, requestOptions));
    }

    private async __findText(
        request: Sandbox.FindTextRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.ResponseList, Sandbox.browserPage.findText.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/find_text",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.ResponseList,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.findText.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.findText.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }

    /**
     * Unified wait: selector, load, url, network_idle, download, function, response, request, or timeout.
     *
     * @param {Sandbox.WaitRequest} request
     * @param {BrowserPage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.browserPage.wait({
     *         type: "selector"
     *     })
     */
    public wait(
        request: Sandbox.WaitRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): core.HttpResponsePromise<core.APIResponse<Sandbox.Response, Sandbox.browserPage.wait.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__wait(request, requestOptions));
    }

    private async __wait(
        request: Sandbox.WaitRequest,
        requestOptions?: BrowserPage.RequestOptions,
    ): Promise<core.WithRawResponse<core.APIResponse<Sandbox.Response, Sandbox.browserPage.wait.Error>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/browser/page/wait",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: {
                    ok: true,
                    body: _response.body as Sandbox.Response,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse,
                },
                rawResponse: _response.rawResponse,
            };
        }

        if (!_response.ok && core.isFailedResponse(_response) && _response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    return {
                        data: {
                            ok: false,
                            error: Sandbox.browserPage.wait.Error.unprocessableEntityError(
                                _response.error.body as Sandbox.HttpValidationError,
                            ),
                            rawResponse: _response.rawResponse,
                        },
                        rawResponse: _response.rawResponse,
                    };
            }
        }

        return {
            data: {
                ok: false,
                error: Sandbox.browserPage.wait.Error._unknown(core.isFailedResponse(_response) ? _response.error : { reason: "unknown", errorMessage: "Unknown error" }),
                rawResponse: _response.rawResponse,
            },
            rawResponse: _response.rawResponse,
        };
    }
}
